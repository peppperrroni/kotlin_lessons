# Урок 2: Операторы в Kotlin

## Введение

Операторы в Kotlin позволяют выполнять различные операции над данными, такие как арифметические вычисления, сравнения, логические операции и многое другое. Kotlin предоставляет богатый набор операторов, многие из которых знакомы разработчикам, использующим другие языки программирования, но также имеет некоторые уникальные особенности.

В этом уроке мы рассмотрим различные типы операторов, доступные в Kotlin, и их применение.

## Арифметические операторы

Арифметические операторы используются для выполнения основных математических операций.

```kotlin
val a = 10
val b = 3

// Основные арифметические операции
val sum = a + b        // Сложение: 13
val difference = a - b // Вычитание: 7
val product = a * b    // Умножение: 30
val quotient = a / b   // Целочисленное деление: 3
val remainder = a % b  // Остаток от деления: 1

// Деление с плавающей точкой
val floatDivision = a.toDouble() / b  // 3.3333333333333335
```

### Инкремент и декремент

Kotlin поддерживает операторы инкремента (`++`) и декремента (`--`), которые могут быть использованы как в префиксной, так и в постфиксной форме.

```kotlin
var c = 5

c++  // Постфиксный инкремент: сначала возвращается значение, затем увеличивается
++c  // Префиксный инкремент: сначала увеличивается, затем возвращается значение

c--  // Постфиксный декремент
--c  // Префиксный декремент
```

Разница между префиксной и постфиксной формами:

```kotlin
var c = 5
val d1 = c++  // d1 = 5, c = 6 (сначала d1 = c, затем c = c + 1)

c = 5
val d2 = ++c  // d2 = 6, c = 6 (сначала c = c + 1, затем d2 = c)
```

## Операторы присваивания

Операторы присваивания используются для присвоения значений переменным, часто в сочетании с другими операциями.

```kotlin
var x = 10

x += 5   // Эквивалентно x = x + 5, результат: 15
x -= 3   // Эквивалентно x = x - 3, результат: 12
x *= 2   // Эквивалентно x = x * 2, результат: 24
x /= 4   // Эквивалентно x = x / 4, результат: 6
x %= 3   // Эквивалентно x = x % 3, результат: 0
```

## Операторы сравнения

Операторы сравнения используются для сравнения значений и возвращают логический результат (`true` или `false`).

```kotlin
val num1 = 10
val num2 = 20

num1 == num2  // Равно: false
num1 != num2  // Не равно: true
num1 < num2   // Меньше: true
num1 > num2   // Больше: false
num1 <= num2  // Меньше или равно: true
num1 >= num2  // Больше или равно: false
```

### Сравнение строк

В Kotlin для сравнения строк используется оператор `==`, который проверяет содержимое строк, а не ссылки на объекты (в отличие от Java).

```kotlin
val str1 = "Привет"
val str2 = "привет"
val str3 = "Привет"

str1 == str2  // Сравнение содержимого: false (регистр различается)
str1 == str3  // Сравнение содержимого: true

// Для сравнения ссылок используется оператор ===
str1 === str3  // Сравнение ссылок: может быть true или false в зависимости от оптимизаций
```

## Логические операторы

Логические операторы используются для выполнения логических операций над булевыми значениями.

```kotlin
val isTrue = true
val isFalse = false

isTrue && isFalse  // Логическое И: false
isTrue || isFalse  // Логическое ИЛИ: true
!isTrue            // Логическое НЕ: false
```

### Короткое замыкание (short-circuit evaluation)

Логические операторы в Kotlin используют короткое замыкание, что означает, что второе выражение не вычисляется, если результат уже определен по первому выражению.

```kotlin
// Для оператора && второе выражение не вычисляется, если первое false
if (isFalse && someExpensiveOperation()) {
    // Этот код не выполнится, и someExpensiveOperation() не будет вызвана
}

// Для оператора || второе выражение не вычисляется, если первое true
if (isTrue || someExpensiveOperation()) {
    // Этот код выполнится, и someExpensiveOperation() не будет вызвана
}
```

## Побитовые операторы

Побитовые операторы выполняют операции на уровне отдельных битов целочисленных типов.

```kotlin
val bit1 = 0b1010  // 10 в двоичной системе
val bit2 = 0b1100  // 12 в двоичной системе

// Побитовое И
val andResult = bit1 and bit2  // 0b1000 (8)

// Побитовое ИЛИ
val orResult = bit1 or bit2    // 0b1110 (14)

// Побитовое исключающее ИЛИ (XOR)
val xorResult = bit1 xor bit2  // 0b0110 (6)

// Побитовое НЕ (инверсия)
val notResult = bit1.inv()     // ~0b1010

// Сдвиг влево
val leftShift = bit1 shl 1     // 0b10100 (20)

// Сдвиг вправо
val rightShift = bit1 shr 1    // 0b0101 (5)

// Беззнаковый сдвиг вправо
val unsignedRightShift = bit1 ushr 1  // 0b0101 (5) для положительных чисел
```

> **Примечание**: В Kotlin побитовые операторы имеют текстовые имена (`and`, `or`, `xor`, `shl`, `shr`, `ushr`) вместо символьных (`&`, `|`, `^`, `<<`, `>>`, `>>>`) как в Java. Это делает код более читаемым и устраняет некоторые проблемы с приоритетом операторов.

## Операторы диапазона

Операторы диапазона позволяют создавать последовательности значений, что особенно полезно в циклах и условиях.

```kotlin
// Включающий диапазон (включает оба конца)
val inclusiveRange = 1..5  // Диапазон от 1 до 5 включительно
3 in inclusiveRange  // true
6 in inclusiveRange  // false

// Исключающий диапазон (не включает верхнюю границу)
val exclusiveRange = 1 until 5  // Диапазон от 1 до 4 (5 не включается)
3 in exclusiveRange  // true
5 in exclusiveRange  // false

// Убывающий диапазон
val descendingRange = 5 downTo 1  // Диапазон от 5 до 1
3 in descendingRange  // true

// Диапазон с шагом
val stepRange = 1..10 step 2  // Диапазон от 1 до 10 с шагом 2 (1, 3, 5, 7, 9)
```

## Оператор Elvis (?:)

Оператор Elvis (`?:`) — это сокращенная форма условного оператора, которая возвращает левую часть, если она не равна `null`, иначе возвращает правую часть.

```kotlin
val nullableValue: String? = null
val nonNullValue = "Не null"

// Если левая часть null, возвращается правая часть
val result1 = nullableValue ?: "Значение по умолчанию"  // "Значение по умолчанию"
val result2 = nonNullValue ?: "Значение по умолчанию"   // "Не null"
```

Этот оператор особенно полезен при работе с nullable типами, позволяя элегантно обрабатывать случаи, когда значение может быть `null`.

## Перегрузка операторов

Kotlin позволяет перегружать операторы, что дает возможность определять поведение операторов для пользовательских типов.

```kotlin
// Определение класса с перегруженными операторами
data class Point(val x: Int, val y: Int) {
    // Перегрузка оператора +
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
    
    // Перегрузка оператора -
    operator fun minus(other: Point): Point {
        return Point(x - other.x, y - other.y)
    }
    
    // Перегрузка оператора *
    operator fun times(factor: Int): Point {
        return Point(x * factor, y * factor)
    }
    
    // Методы toString() и equals() автоматически реализуются в data классах
}

// Использование перегруженных операторов
val point1 = Point(3, 4)
val point2 = Point(1, 2)

val point3 = point1 + point2  // Point(x=4, y=6)
val point4 = point1 - point2  // Point(x=2, y=2)
val point5 = point1 * 2       // Point(x=6, y=8)

point1 == Point(3, 4)  // true (благодаря автоматической реализации equals() в data классе)
```

Для перегрузки оператора необходимо определить функцию с ключевым словом `operator` и соответствующим именем (например, `plus` для `+`, `minus` для `-` и т.д.).

## Заключение

В этом уроке мы рассмотрели различные операторы, доступные в Kotlin, включая арифметические, присваивания, сравнения, логические, побитовые, диапазона, а также специальные операторы, такие как Elvis и перегрузка операторов.

Ключевые особенности операторов в Kotlin:
- Текстовые имена для побитовых операторов, что делает код более читаемым
- Оператор Elvis (`?:`) для элегантной обработки nullable значений
- Возможность перегрузки операторов для пользовательских типов
- Операторы диапазона для удобного создания последовательностей значений

Понимание операторов и их правильное использование является важной частью эффективного программирования на Kotlin. 